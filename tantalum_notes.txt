vbo: vertex buffer
 - Position vec3
 - TexCoord vec2

fbo: render target


shaders order:
 - init
 - trace
 - ray
 - pass
 - compose

RayState.posTex is initialized as ((0,0), random dir)
         rngTex as a random number
         rgbTex as 0

init shader:
 - gl_FragData[0] = vec4(pos, dir);
 - gl_FragData[1] = state; // random number (seed?)
 - gl_FragData[2] = vec4(rgb, lambda); // emitter rgb and wavelength

trace shader:
 - posTex ray, intersect with scene
 - sample output direction (local)
 - gl_FragData[0] = posDir; // new ray, or previous if no intersection
 - gl_FragData[1] = state; // random number (seed?)
 - gl_FragData[2] = rgbLambda; // background color (black) or sample color (depends on previous value, comes from rgbData)

ray shader:
 - interpola posiciÃ³n entre A y B, y normaliza respecto a aspect ratio
 - gl_FragColor = color de la textura

pass shader:
 - gl_FragColor = waveBuffer

compose shader:
 - gl_FragColor = (screenBuffer * exposure)^(1/2.2)


 ------
 Old code in h-vert.txt
    // Assuming uniformly distributed along a line from (1.2,1) to (1.2,-1), in the center of the divisions
    float yIntervalSize = 2.0 / float(numSpads);
    float yN = floor (posA.y / yIntervalSize);
    float spadY = yN*yIntervalSize + yIntervalSize/2.0;
    // x=1.2 is the position of the relay wall
    if (distance(posA, vec2(1.2, spadY)) > spadRadius) {
        gl_Position = vec4(vec3(-1.0), 1.0);
    } else {
        float t = t0 / tmax;
        gl_Position = vec4(2.0*t-1.0, posA.y, 0.0, 1.0);
        gl_PointSize = 1.0;
        vColor = texture2D(RgbData, TexCoord.xy).rgb*biasCorrection;
    }

    // Assuming uniformly distributed along a line from (1.2,startPoint.y) to (1.2,startPoint.y+spadDist.y*numSpads), in the divisions
    // The result does not resemble previous one as much as I would like
    /*yIntervalSize = spadDist.y;
    vec2 endPoint = startPoint + vec2(numSpads-1) * spadDist;
    float yLength = yIntervalSize * float(numSpads);
    yN = floor(float(numSpads) * (posA.y - (startPoint.y - spadRadius)) / yLength);
    spadY = yN*yIntervalSize + startPoint.y;
    // x=1.2 is the position of the relay wall
    if (yN < 0.0 || yN > float(numSpads) || distance(posA, vec2(1.2, spadY)) > spadRadius) {
        gl_Position = vec4(vec3(-1.0), 1.0);
    } else {
        float t = t0 / tmax;
        gl_Position = vec4(2.0*t-1.0, yN*2.0/float(numSpads)-1.0, 0.0, 1.0);
        gl_PointSize = 1.0;
        vColor = texture2D(RgbData, TexCoord.xy).rgb*biasCorrection;
    }*/

    /*yIntervalSize = spadDist.y;
    vec2 endPoint = startPoint + vec2(numSpads-1) * spadDist;
    yN = (posA.y - startPoint.y) / yIntervalSize;
    if (yN < 0.0) {
        yN = 0.0;
    } else {
        float integerPart, decimalPart;
        integerPart = floor(yN);
        decimalPart = yN - integerPart;
        yN = integerPart + float(decimalPart > 0.5);
    }
    spadY = startPoint.y + yN * yIntervalSize;
    if (distance(posA, vec2(1.2, spadY)) > spadRadius) {
        gl_Position = vec4(vec3(-1.0), 1.0);
    } else {
        float t = t0 / tmax;
        gl_Position = vec4(2.0*t-1.0, yN*2.0/float(numSpads)-1.0, 0.0, 1.0);
        gl_PointSize = 1.0;
        vColor = texture2D(RgbData, TexCoord.xy).rgb*biasCorrection;
    }*/