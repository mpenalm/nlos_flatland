#include "preamble"

uniform sampler2D PosDataA;
uniform sampler2D PosDataB;
uniform sampler2D RgbData;
uniform sampler2D TimeDataA;
uniform sampler2D SpadGrid;
uniform sampler2D SpadNormals;

uniform float tmax;
uniform float spadRadius;
uniform vec2 spadPos;    // Position of the physical spad device
uniform vec2 startPoint; // Location of first spad point (lowest y value)
uniform vec2 spadDist;   // Distance between spad points
//uniform int numSpads;

attribute vec2 TexCoord;

varying vec3 vColor;

const int numSpads = {numSpads};

void main() {
    gl_Position = vec4(vec3(-1.0), 1.0);

    vec2 posA = texture2D(PosDataA, TexCoord.xy).xy;
    vec2 posB = texture2D(PosDataB, TexCoord.xy).xy;
    vec2 dir = posB - posA;
    float t0 = texture2D(TimeDataA, TexCoord.xy).x;
    float biasCorrection = clamp(length(dir)/max(abs(dir.x), abs(dir.y)), 1.0, 1.414214);

    vec2 spadPoint;
    for (int i = 0; i < numSpads; i++) {
        float y = (float(i) + 0.5) / float(numSpads);
        spadPoint = texture2D(SpadGrid, vec2(y, 0.5)).xy;

        if (distance(posA, spadPoint) <= spadRadius) {
            float t = t0 + distance(posA, spadPos); // Time needed to reach the sensor, assuming vacuum and no occlusions
            //t = t0;
            float x = t / tmax * 2.0 - 1.0;
            y = 2.0 * y - 1.0;

            vec2 n = texture2D(SpadNormals, vec2(y, 0.5)).xy;
            n = vec2(-1.0, 0.0);
            vec2 dir = spadPos - posA;
            float cosine = dot(n, dir);

            gl_PointSize = 1.0;
            gl_Position = vec4(x, y, 0.0, 1.0);
            vColor = max(vec3(0.0), cosine * texture2D(RgbData, TexCoord.xy).rgb*biasCorrection / vec3(spadRadius*spadRadius*PI));
            break;
        }
    }

    /*vec2 endPoint = startPoint + vec2(numSpads-1) * spadDist;
    vec2 nv = (posA - startPoint) / spadDist;
    float n = mix(nv.x, nv.y, float(spadDist.y != 0.0));
    // the if works but the mix or sum of mults do not
    if (spadDist.y == 0.0) {
        n = nv.x;
    } else {
        n = nv.y;
    }
    if (n < 0.0) {
        n = 0.0;
    } else {
        float integerPart, decimalPart;
        integerPart = floor(n);
        decimalPart = n - integerPart;
        n = integerPart + float(decimalPart > 0.5);
    }
    vec2 spadPoint = startPoint + vec2(n) * spadDist;
    if (distance(posA, spadPoint) > spadRadius) {
        gl_Position = vec4(vec3(-1.0), 1.0);
    } else {
        float dsp = distance(posA, spadPos);
        dsp = 0.0;
        float t = (t0 + dsp) / tmax;
        gl_Position = vec4(2.0*t-1.0, (n+0.5)*2.0/float(numSpads)-1.0, 0.0, 1.0);
        gl_PointSize = 1.0;
        vec2 n = vec2(-1.0, 0.0);
        vec2 dir = spadPos - posA;
        float cosine = dot(n, dir);
        cosine = 1.0;
        vColor = cosine * texture2D(RgbData, TexCoord.xy).rgb*biasCorrection; // / vec3(spadRadius*spadRadius*PI);
    }*/
}
